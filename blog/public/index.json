[{"content":"Rocky III (1982) Rocky Balboa (Sylvester Stallone) takes on Clubber Lang (Mr. T) in the third installment of the Rocky series.\nRating: 4/5\nSynopsis Rocky Balboa is now a boxing legend, defending his title (gained in his last bout with Apollo Creed) many times over against cherry picked opponents. He is famous and wealthy as a boxer, frequently filming commericials and appearing in billboards. When Balboa announces his retirement, one Clubber Lang calls him out for the last match of his career.\nRocky trains for the match, though not with the same passion as before. Thus, when their first fight comes, Clubber pummels Rocky, and kills his trainer Mick.\nBored with retirement, Apollo Creed decides to train Rocky at his old gym in Los Angeles. At first, Rocky is docile, clearly missing his old hunger. After speeches from Adrianne (Talia Shire) and Apollo, he whips into the best shape of his career, finally defeating Lang.\nReview This was a very solid addition to my favorite movie franchise ever. We see rivals become friends to overcome the new villain. This calls for some great lines, including my favorite in the movie:\n\u0026ldquo;There is no tomorrow! There is no tomorrow!\u0026rdquo;\nDuring each of these films, I\u0026rsquo;d always wondered why Rocky tolerated Paulie (Burt Young). Paulie was a loser who expected everything to be handed to him.\nI also wondered how Apollo Creed would fare against Clubber Lang. I feel like Rocky was essentially Apollo after being trained by him, so prime Apollo could likely take Clubber.\nI felt that the movie could have been paced a little bit better. The first half was very slow, but the second half was really great. As many have pointed out, the whole Thunderlips scene added nothing to the movie, but I liked it nonetheless.\nNotable lines:\n\u0026ldquo;No, I don\u0026rsquo;t hate Balboa. I pity the fool, and I will destroy any man who tries to take what I got!\u0026rdquo;\n\u0026ldquo;The worst thing that happened to you, that can happen to any fighter: you got civilized.\u0026rdquo;\n","permalink":"https://www.dumrich.com/posts/rocky-iii/","summary":"Rocky III (1982) Rocky Balboa (Sylvester Stallone) takes on Clubber Lang (Mr. T) in the third installment of the Rocky series.\nRating: 4/5\nSynopsis Rocky Balboa is now a boxing legend, defending his title (gained in his last bout with Apollo Creed) many times over against cherry picked opponents. He is famous and wealthy as a boxer, frequently filming commericials and appearing in billboards. When Balboa announces his retirement, one Clubber Lang calls him out for the last match of his career.","title":"Rocky III (1982) Movie Review"},{"content":"Unix systems have two ways of doing Input/Output (I/O) in C:\nPOSIX File I/O ISO C Standard I/O There are 2 different interfaces for I/O because the latter is meant to be portable. C implmentations must provide the \u0026lt;stdio.h\u0026gt; header, so it could work theoretically for any C implementation.\nThe POSIX implementation are unbuffered (more on that later), and usually invoke direct system calls to the kernel.\nThis post will go over both of types of I/O by implementing a very simple Swiper-like utility (for use in the Cemacs editor) in two different ways.\nSources: APUE, TLPI\nPOSIX File I/O At the core of the unbuffered POSIX functions are file descriptors. File descriptors are non-negative integers that are used to identify open files.\nIn C, three file descriptors (always the smallest numbers), are automatically reserved for the standard input, the standard output and the standard error (STDIN_FILNO, STDOUT_FILENO, and STDERR_FILENO in \u0026lt;unistd.h\u0026gt;).\nIn Unix, these are considered files, which we can read and write to as any other.\nOne thing to note about file descriptors, is that the operating system will always assign an open file the smallest file descriptor. For example, if the programmer decides to open a new file at the very beginning of the main function, the file will likely have the descriptor of 3, as 0, 1, and 2 are already reserved.\nBasic implementation We start with our interface function; It usually takes a *Editor, but for our purposes, we\u0026rsquo;ll reduce it down to the pathname and the string we want to search for. We will also test it in a :\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #define BUFFSIZE 4096 void find_in_file(int, size_t, char*); int main() { /* Open File with flags */ int fd = open(\u0026#34;unix-file-io.org\u0026#34;, O_RDONLY|O_CREAT); find_in_file(fd, \u0026#34;file\u0026#34;); return close(fd); } First, we include some headers, specifically:\n\u0026lt;unistd.h\u0026gt; gives us the close, lseek functions. \u0026lt;fcntl.h\u0026gt; gives us the open function, and oflag constants \u0026lt;ctype.h\u0026gt; gives us the tolower function We also define the function find_in_file and the buffer size.\nThe buffer size will be how many bytes we will read from the file at a time. More on this later.\nThe open function takes a path, and some flags, and returns a file descriptor. This file descriptor is how we will refer to the file from here on out. On most Unix systems, this will be the value 3, as it is the smallest available integer.\nDifferent flags can be Or\u0026rsquo;d together to create a mode that will determine access permissions.\nO_RDONLY opens the file for only reading O_WRONLY opens the file for only writing O_RDWR opens the file for both Optional:\nO_APPEND appends to the file after every write O_CREAT creates the file if it doesn\u0026rsquo;t exist A complete list can be found here.\nIn this case, we Or the RDONLY flag, and the CREAT flag. This means, that we can only read the file, and if it doesn\u0026rsquo;t exist, it will be created. If we Or\u0026rsquo;d with a write flag, we would also be able to write to the file.\nNext, we call our function, giving it the name \u0026ldquo;file\u0026rdquo;.\nFinally, we close the file. When the process exits, the open files automatically close.\nNext, the find_in_file function:\nchar buf[BUFFSIZE]; void find_in_file(int fd, char* phrase) { int current_line = 1; bool is_eof = false; int match_length = strlen(phrase); int buf_len; while(!is_eof) { if((buf_len = read(fd, buf, BUFFSIZE)) != BUFFSIZE) { is_eof = true; } for(int i = 0; i \u0026lt; buf_len - strlen(phrase); i++) { int cur_cmp = 0; while(cur_cmp \u0026lt; match_length) { if(buf[i+cur_cmp] == \u0026#39;\\n\u0026#39;) { current_line++; goto result; } if(tolower(buf[i + cur_cmp]) != tolower(phrase[cur_cmp])) { goto result; } else { cur_cmp++; } } printf(\u0026#34;Line: %d\\n\u0026#34;, current_line); result: continue; } } } First, we create a buffer of size BUFFSIZE.\nThen, we set some preliminary flags. The initial line is 1, and the offset has not reached the end of file. Finally, we set the length of the phrase to how many characters we have to match.\nNow, we read BUFFSIZE bytes into the buffer. read returns the number of bytes it read, so if that number is less than the size of the buffer, we know that we have reached the end of the file. In that case, the while loop won\u0026rsquo;t loop again.\nNow that the bytes are in the buffer, we iterate through the current buffer with an algorithm to check if the characters match.\nWe check how many characters have been matched, and if the number of characters matched is equal to the length of the phrase, that is a match. If so, we print the line number. We increment the line number if we encounter a newline character.\nOther Functions There are some other functions that may be useful to know.\ncreat #include \u0026lt;fcntl.h\u0026gt; int creat(const char* path, mode_t mode); This function is equal to open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);\nNotice how it is opened for writing only.\nlseek The lseek function is another useful function that is used to manipulate the offset (aka current position in a file).\n#include \u0026lt;unistd.h\u0026gt; off_t lseek(int fd, off_t offset, int whence); offset could mean different things depending on whence.\nIf whence is SEEK_SET, the files current position if offset from the beginning. If whence is SEEK_CUR, the files current position if offset from the current position. If whence is SEEK_END, the files current position if offset from the size of the file. If you seek past the end of the file, that creates a hole in the file. The hole is not backed by a storage medium.\nReading and writing operations also manage the offset of the file.\ndup and dup2 The dup functions just clone the file descriptor in the file descriptor table of that process. One special thing about the dup function is that it chooses the lowest available file descriptor, allowing us to do some special things that we will see later.\n#include \u0026lt;unistd.h\u0026gt; int dup(int fd); int dup2(int fd, int fd2); dup duplicates fd and gives the result descriptor the lowest available identifier. dup2 duplicates fd, giving the new one fd2. If fd2 is open, it closes it.\ndup can be used to, for example, redirect stdout to a file like this:\nclose(1); dup(34); We clone the file descriptor of some file, duplicating it on standard output.\nsync functions Unix systems have a buffer cache that IO runs through. When we write to a file, it usually passes through the kernel\u0026rsquo;s buffer cache, and is written at some later time.\nThe buffer is written eventually, especially when the buffer needs to be reused. The sync functions just flush the buffer cache.\n#include \u0026lt;unistd.h\u0026gt; int fsync(int fd); void sync(void); sync queues block buffers for writing. It doesn\u0026rsquo;t wait for the writing to take place fsync queues only one file descriptor for writing. It does wait for the writing to take place.\nC Standard I/O The C Standard I/O works a little bit differently. We still read and write and interact with files, but this I/O is a little bit more featureful because it comes with internal buffering. The FILE object maintains its own buffer so it doesn\u0026rsquo;t have to make a system call to read or write every single time.\nIt may read a little more the first time, so it would just be getting data from its own buffer.\nThe 3 kinds of I/O are:\nCharacter I/O, where one character is read or written Line I/O, where one line is read or written Direct I/O, where the exact number of objects and size of each object is specified. Buffering The main benefit of standard IO is the default buffering functionalities, which aims to reduce the number of read and write calls a process makes.\nThere are 3 kinds of buffering:\nFully buffered streams maintain a dynamically allocated buffer. The IO is only performed once the buffer is filled up, or the process flushes the buffers.\nA process can flush a buffer by calling fflush(3) or exit(3)\nMost file streams are fully buffered\nLine buffered streams only perform input or output when they encounter a new line (\u0026rsquo;\\n\u0026rsquo;) character. You can write characters to a buffer, and know that they aren\u0026rsquo;t being flushed unless the newline character is written.\nTerminal streams like stdout are line buffered\nUnbuffered streams just read and write directly.\nstderr is unbuffered because the result should appear whether or not a newline is encountered.\nSet buffering Buffering can be set using setbuf(3) and setvbuf(3). View the man pages for a more detailed look at the functions.\nBasic implementation This is a basic implementation with buffering. This time when we use fopen, we are returned a FILE*. Instead of Or-ing options, we can just add a string of permissions. In this case, we only need \u0026ldquo;r\u0026rdquo; (read) permissions.\n#define BUFFSIZE 4096 void find_in_file(FILE*, const char*); int main() { /* Open File with flags */ FILE* fd = fopen(\u0026#34;search.c\u0026#34;, \u0026#34;r\u0026#34;); find_in_file(fd, \u0026#34;file\u0026#34;); return fclose(fd); } Now, we implement the same basic algorithm as before:\nchar buf[BUFFSIZE]; void find_in_file(FILE* fp, const char* phrase) { int current_line = 1; const int match_length = strlen(phrase); while(fgets(buf, BUFFSIZE, fp)) { int buf_len = strlen(buf); if(buf_len \u0026lt; match_length) { continue; } for(int i = 0; i \u0026lt; buf_len - match_length; i++) { int cur_cmp = 0; while(cur_cmp \u0026lt; match_length) { if(tolower((unsigned char)buf[i + cur_cmp]) != tolower((unsigned char)phrase[cur_cmp])) { goto result; } else { cur_cmp++; } } printf(\u0026#34;Line: %d\\n\u0026#34;, current_line); result: continue; } current_line++; } } This time fgets reads only one line at a time into the buffer. We implement the same algorithm, though this one works a little bit better.\nOther Functions Some functions commonly used for Binary I/O are the fread and write functions.\nFor example, a binary array can be written to a file as such:\nfloat buf[8] = {1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1}; int main(void) { fwrite(\u0026amp;buf[2], sizeof(float), 2, stdout); exit(0); } Also, an equivalent to the lseek function above is fseek and ftell.\nftell simply returns the current offset.\nfseek can be used to set the offset, with the same file modes.\n#include \u0026lt;stdio.h\u0026gt; long ftell(FILE* fp); int fseek(FILE* fp, long offset, int whence); Temp files #include \u0026lt;stdio.h\u0026gt; char* tmpname(char*); FILE* tmpfile(void); These functions can be used to generate a temporary file. tmpname just returns the pathname, whereas tmpfile returns the stream.\n","permalink":"https://www.dumrich.com/posts/unix-file-io/","summary":"Unix systems have two ways of doing Input/Output (I/O) in C:\nPOSIX File I/O ISO C Standard I/O There are 2 different interfaces for I/O because the latter is meant to be portable. C implmentations must provide the \u0026lt;stdio.h\u0026gt; header, so it could work theoretically for any C implementation.\nThe POSIX implementation are unbuffered (more on that later), and usually invoke direct system calls to the kernel.\nThis post will go over both of types of I/O by implementing a very simple Swiper-like utility (for use in the Cemacs editor) in two different ways.","title":"File I/O on Unix systems"}]