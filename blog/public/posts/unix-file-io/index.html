<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>File I/O on Unix systems | dumrich.com</title>
<meta name="keywords" content="Unix, C, Files">
<meta name="description" content="Unix systems have two ways of doing Input/Output (I/O) in C:
POSIX File I/O ISO C Standard I/O There are 2 different interfaces for I/O because the latter is meant to be portable. C implmentations must provide the &lt;stdio.h&gt; header, so it could work theoretically for any C implementation.
The POSIX implementation are unbuffered (more on that later), and usually invoke direct system calls to the kernel.
This post will go over both of types of I/O by implementing a very simple Swiper-like utility (for use in the Cemacs editor) in two different ways.">
<meta name="author" content="  &#34;Abhinav Chavali&#34;
  ">
<link rel="canonical" href="https://www.dumrich.com/posts/unix-file-io/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css" integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://www.dumrich.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://www.dumrich.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://www.dumrich.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://www.dumrich.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://www.dumrich.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="File I/O on Unix systems" />
<meta property="og:description" content="Unix systems have two ways of doing Input/Output (I/O) in C:
POSIX File I/O ISO C Standard I/O There are 2 different interfaces for I/O because the latter is meant to be portable. C implmentations must provide the &lt;stdio.h&gt; header, so it could work theoretically for any C implementation.
The POSIX implementation are unbuffered (more on that later), and usually invoke direct system calls to the kernel.
This post will go over both of types of I/O by implementing a very simple Swiper-like utility (for use in the Cemacs editor) in two different ways." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.dumrich.com/posts/unix-file-io/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-31T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2022-07-31T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="File I/O on Unix systems"/>
<meta name="twitter:description" content="Unix systems have two ways of doing Input/Output (I/O) in C:
POSIX File I/O ISO C Standard I/O There are 2 different interfaces for I/O because the latter is meant to be portable. C implmentations must provide the &lt;stdio.h&gt; header, so it could work theoretically for any C implementation.
The POSIX implementation are unbuffered (more on that later), and usually invoke direct system calls to the kernel.
This post will go over both of types of I/O by implementing a very simple Swiper-like utility (for use in the Cemacs editor) in two different ways."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://www.dumrich.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "File I/O on Unix systems",
      "item": "https://www.dumrich.com/posts/unix-file-io/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "File I/O on Unix systems",
  "name": "File I\/O on Unix systems",
  "description": "Unix systems have two ways of doing Input/Output (I/O) in C:\nPOSIX File I/O ISO C Standard I/O There are 2 different interfaces for I/O because the latter is meant to be portable. C implmentations must provide the \u0026lt;stdio.h\u0026gt; header, so it could work theoretically for any C implementation.\nThe POSIX implementation are unbuffered (more on that later), and usually invoke direct system calls to the kernel.\nThis post will go over both of types of I/O by implementing a very simple Swiper-like utility (for use in the Cemacs editor) in two different ways.",
  "keywords": [
    "Unix", "C", "Files"
  ],
  "articleBody": "Unix systems have two ways of doing Input/Output (I/O) in C:\nPOSIX File I/O ISO C Standard I/O There are 2 different interfaces for I/O because the latter is meant to be portable. C implmentations must provide the header, so it could work theoretically for any C implementation.\nThe POSIX implementation are unbuffered (more on that later), and usually invoke direct system calls to the kernel.\nThis post will go over both of types of I/O by implementing a very simple Swiper-like utility (for use in the Cemacs editor) in two different ways.\nSources: APUE, TLPI\nPOSIX File I/O At the core of the unbuffered POSIX functions are file descriptors. File descriptors are non-negative integers that are used to identify open files.\nIn C, three file descriptors (always the smallest numbers), are automatically reserved for the standard input, the standard output and the standard error (STDIN_FILNO, STDOUT_FILENO, and STDERR_FILENO in ).\nIn Unix, these are considered files, which we can read and write to as any other.\nOne thing to note about file descriptors, is that the operating system will always assign an open file the smallest file descriptor. For example, if the programmer decides to open a new file at the very beginning of the main function, the file will likely have the descriptor of 3, as 0, 1, and 2 are already reserved.\nBasic implementation We start with our interface function; It usually takes a *Editor, but for our purposes, we’ll reduce it down to the pathname and the string we want to search for. We will also test it in a :\n#include #include #include #include #include #include #define BUFFSIZE 4096 void find_in_file(int, size_t, char*); int main() { /* Open File with flags */ int fd = open(\"unix-file-io.org\", O_RDONLY|O_CREAT); find_in_file(fd, \"file\"); return close(fd); } First, we include some headers, specifically:\ngives us the close, lseek functions. gives us the open function, and oflag constants gives us the tolower function We also define the function find_in_file and the buffer size.\nThe buffer size will be how many bytes we will read from the file at a time. More on this later.\nThe open function takes a path, and some flags, and returns a file descriptor. This file descriptor is how we will refer to the file from here on out. On most Unix systems, this will be the value 3, as it is the smallest available integer.\nDifferent flags can be Or’d together to create a mode that will determine access permissions.\nO_RDONLY opens the file for only reading O_WRONLY opens the file for only writing O_RDWR opens the file for both Optional:\nO_APPEND appends to the file after every write O_CREAT creates the file if it doesn’t exist A complete list can be found here.\nIn this case, we Or the RDONLY flag, and the CREAT flag. This means, that we can only read the file, and if it doesn’t exist, it will be created. If we Or’d with a write flag, we would also be able to write to the file.\nNext, we call our function, giving it the name “file”.\nFinally, we close the file. When the process exits, the open files automatically close.\nNext, the find_in_file function:\nchar buf[BUFFSIZE]; void find_in_file(int fd, char* phrase) { int current_line = 1; bool is_eof = false; int match_length = strlen(phrase); int buf_len; while(!is_eof) { if((buf_len = read(fd, buf, BUFFSIZE)) != BUFFSIZE) { is_eof = true; } for(int i = 0; i \u003c buf_len - strlen(phrase); i++) { int cur_cmp = 0; while(cur_cmp \u003c match_length) { if(buf[i+cur_cmp] == '\\n') { current_line++; goto result; } if(tolower(buf[i + cur_cmp]) != tolower(phrase[cur_cmp])) { goto result; } else { cur_cmp++; } } printf(\"Line: %d\\n\", current_line); result: continue; } } } First, we create a buffer of size BUFFSIZE.\nThen, we set some preliminary flags. The initial line is 1, and the offset has not reached the end of file. Finally, we set the length of the phrase to how many characters we have to match.\nNow, we read BUFFSIZE bytes into the buffer. read returns the number of bytes it read, so if that number is less than the size of the buffer, we know that we have reached the end of the file. In that case, the while loop won’t loop again.\nNow that the bytes are in the buffer, we iterate through the current buffer with an algorithm to check if the characters match.\nWe check how many characters have been matched, and if the number of characters matched is equal to the length of the phrase, that is a match. If so, we print the line number. We increment the line number if we encounter a newline character.\nOther Functions There are some other functions that may be useful to know.\ncreat #include int creat(const char* path, mode_t mode); This function is equal to open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);\nNotice how it is opened for writing only.\nlseek The lseek function is another useful function that is used to manipulate the offset (aka current position in a file).\n#include off_t lseek(int fd, off_t offset, int whence); offset could mean different things depending on whence.\nIf whence is SEEK_SET, the files current position if offset from the beginning. If whence is SEEK_CUR, the files current position if offset from the current position. If whence is SEEK_END, the files current position if offset from the size of the file. If you seek past the end of the file, that creates a hole in the file. The hole is not backed by a storage medium.\nReading and writing operations also manage the offset of the file.\ndup and dup2 The dup functions just clone the file descriptor in the file descriptor table of that process. One special thing about the dup function is that it chooses the lowest available file descriptor, allowing us to do some special things that we will see later.\n#include int dup(int fd); int dup2(int fd, int fd2); dup duplicates fd and gives the result descriptor the lowest available identifier. dup2 duplicates fd, giving the new one fd2. If fd2 is open, it closes it.\ndup can be used to, for example, redirect stdout to a file like this:\nclose(1); dup(34); We clone the file descriptor of some file, duplicating it on standard output.\nsync functions Unix systems have a buffer cache that IO runs through. When we write to a file, it usually passes through the kernel’s buffer cache, and is written at some later time.\nThe buffer is written eventually, especially when the buffer needs to be reused. The sync functions just flush the buffer cache.\n#include int fsync(int fd); void sync(void); sync queues block buffers for writing. It doesn’t wait for the writing to take place fsync queues only one file descriptor for writing. It does wait for the writing to take place.\nC Standard I/O The C Standard I/O works a little bit differently. We still read and write and interact with files, but this I/O is a little bit more featureful because it comes with internal buffering. The FILE object maintains its own buffer so it doesn’t have to make a system call to read or write every single time.\nIt may read a little more the first time, so it would just be getting data from its own buffer.\nThe 3 kinds of I/O are:\nCharacter I/O, where one character is read or written Line I/O, where one line is read or written Direct I/O, where the exact number of objects and size of each object is specified. Buffering The main benefit of standard IO is the default buffering functionalities, which aims to reduce the number of read and write calls a process makes.\nThere are 3 kinds of buffering:\nFully buffered streams maintain a dynamically allocated buffer. The IO is only performed once the buffer is filled up, or the process flushes the buffers.\nA process can flush a buffer by calling fflush(3) or exit(3)\nMost file streams are fully buffered\nLine buffered streams only perform input or output when they encounter a new line (’\\n’) character. You can write characters to a buffer, and know that they aren’t being flushed unless the newline character is written.\nTerminal streams like stdout are line buffered\nUnbuffered streams just read and write directly.\nstderr is unbuffered because the result should appear whether or not a newline is encountered.\nSet buffering Buffering can be set using setbuf(3) and setvbuf(3). View the man pages for a more detailed look at the functions.\nBasic implementation This is a basic implementation with buffering. This time when we use fopen, we are returned a FILE*. Instead of Or-ing options, we can just add a string of permissions. In this case, we only need “r” (read) permissions.\n#define BUFFSIZE 4096 void find_in_file(FILE*, const char*); int main() { /* Open File with flags */ FILE* fd = fopen(\"search.c\", \"r\"); find_in_file(fd, \"file\"); return fclose(fd); } Now, we implement the same basic algorithm as before:\nchar buf[BUFFSIZE]; void find_in_file(FILE* fp, const char* phrase) { int current_line = 1; const int match_length = strlen(phrase); while(fgets(buf, BUFFSIZE, fp)) { int buf_len = strlen(buf); if(buf_len \u003c match_length) { continue; } for(int i = 0; i \u003c buf_len - match_length; i++) { int cur_cmp = 0; while(cur_cmp \u003c match_length) { if(tolower((unsigned char)buf[i + cur_cmp]) != tolower((unsigned char)phrase[cur_cmp])) { goto result; } else { cur_cmp++; } } printf(\"Line: %d\\n\", current_line); result: continue; } current_line++; } } This time fgets reads only one line at a time into the buffer. We implement the same algorithm, though this one works a little bit better.\nOther Functions Some functions commonly used for Binary I/O are the fread and write functions.\nFor example, a binary array can be written to a file as such:\nfloat buf[8] = {1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1}; int main(void) { fwrite(\u0026buf[2], sizeof(float), 2, stdout); exit(0); } Also, an equivalent to the lseek function above is fseek and ftell.\nftell simply returns the current offset.\nfseek can be used to set the offset, with the same file modes.\n#include long ftell(FILE* fp); int fseek(FILE* fp, long offset, int whence); Temp files #include char* tmpname(char*); FILE* tmpfile(void); These functions can be used to generate a temporary file. tmpname just returns the pathname, whereas tmpfile returns the stream.\n",
  "wordCount" : "1730",
  "inLanguage": "en",
  "datePublished": "2022-07-31T00:00:00Z",
  "dateModified": "2022-07-31T00:00:00Z",
  "author":[{
    "@type": "Person",
    "name": "  \"Abhinav Chavali\"\n  "
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.dumrich.com/posts/unix-file-io/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "dumrich.com",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.dumrich.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://www.dumrich.com/" accesskey="h" title="dumrich.com (Alt + H)">dumrich.com</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://www.dumrich.com/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://www.dumrich.com/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://www.dumrich.com/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/dumrich" title="GitHub">
                    <span>GitHub</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://www.dumrich.com/">Home</a>&nbsp;»&nbsp;<a href="https://www.dumrich.com/posts/">Posts</a></div>
    <h1 class="post-title">
      File I/O on Unix systems
    </h1>
    <div class="post-meta"><span title='2022-07-31 00:00:00 +0000 UTC'>July 31, 2022</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;  "Abhinav Chavali"
  &nbsp;|&nbsp;<a href="https://github.com/dumrich/SiteBackup/tree/master/blog/content-org/content/posts/unix-file-io.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#posix-file-i-o" aria-label="POSIX File I/O">POSIX File I/O</a><ul>
                        
                <li>
                    <a href="#basic-implementation" aria-label="Basic implementation">Basic implementation</a></li>
                <li>
                    <a href="#other-functions" aria-label="Other Functions">Other Functions</a><ul>
                        
                <li>
                    <a href="#creat" aria-label="creat"><code>creat</code></a></li>
                <li>
                    <a href="#lseek" aria-label="lseek"><code>lseek</code></a></li>
                <li>
                    <a href="#dup-and-dup2" aria-label="dup and dup2"><code>dup</code> and <code>dup2</code></a></li>
                <li>
                    <a href="#sync-functions" aria-label="sync functions"><code>sync</code> functions</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#c-standard-i-o" aria-label="C Standard I/O">C Standard I/O</a><ul>
                        
                <li>
                    <a href="#buffering" aria-label="Buffering">Buffering</a><ul>
                        
                <li>
                    <a href="#set-buffering" aria-label="Set buffering">Set buffering</a></li></ul>
                </li>
                <li>
                    <a href="#basic-implementation" aria-label="Basic implementation">Basic implementation</a></li>
                <li>
                    <a href="#other-functions" aria-label="Other Functions">Other Functions</a><ul>
                        
                <li>
                    <a href="#temp-files" aria-label="Temp files">Temp files</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Unix systems have two ways of doing Input/Output (I/O) in C:</p>
<ul>
<li>POSIX File I/O</li>
<li>ISO C Standard I/O</li>
</ul>
<p>There are 2 different interfaces for I/O because the latter is meant to be portable. C implmentations must provide the <code>&lt;stdio.h&gt;</code> header, so it could work theoretically for any C implementation.</p>
<p>The POSIX implementation are unbuffered (more on that later), and usually invoke direct system calls to the kernel.</p>
<p>This post will go over both of types of I/O by implementing a very simple <a href="https://github.com/abo-abo/swiper#swiper">Swiper</a>-like utility (for use in the <a href="https://git.dumrich.com/chabi/cemacs">Cemacs editor</a>) in two different ways.</p>
<p>Sources: <a href="https://www.amazon.com/Advanced-Programming-UNIX-Environment-3rd/dp/0321637739">APUE</a>, <a href="https://www.amazon.com/Linux-Programming-Interface-System-Handbook/dp/1593272200/ref=pd_lpo_1?pd_rd_i=1593272200&amp;psc=1">TLPI</a></p>
<h2 id="posix-file-i-o">POSIX File I/O<a hidden class="anchor" aria-hidden="true" href="#posix-file-i-o">#</a></h2>
<p>At the core of the unbuffered POSIX functions are <code>file descriptors</code>. File descriptors are non-negative integers that are used to identify open files.</p>
<p>In C, three file descriptors (always the smallest numbers), are automatically reserved for the standard input, the standard output and the standard error (<code>STDIN_FILNO</code>, <code>STDOUT_FILENO</code>, and <code>STDERR_FILENO</code> in <code>&lt;unistd.h&gt;</code>).</p>
<p>In Unix, these are considered files, which we can read and write to as any other.</p>
<p>One thing to note about file descriptors, is that the operating system will always assign an open file the smallest file descriptor. For example, if the programmer decides to open a new file at the very beginning of the main function, the file will likely have the descriptor of <code>3</code>, as 0, 1, and 2 are already reserved.</p>
<h3 id="basic-implementation">Basic implementation<a hidden class="anchor" aria-hidden="true" href="#basic-implementation">#</a></h3>
<p>We start with our interface function; It usually takes a <code>*Editor</code>, but for our purposes, we&rsquo;ll reduce it down to the pathname and the string we want to search for. We will also test it in a :</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdbool.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;ctype.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define BUFFSIZE 4096
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">find_in_file</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">size_t</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Open File with flags */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">&#34;unix-file-io.org&#34;</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="o">|</span><span class="n">O_CREAT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">find_in_file</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="s">&#34;file&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>First, we include some headers, specifically:</p>
<ul>
<li><code>&lt;unistd.h&gt;</code> gives us the close, lseek functions.</li>
<li><code>&lt;fcntl.h&gt;</code> gives us the open function, and oflag constants</li>
<li><code>&lt;ctype.h&gt;</code> gives us the tolower function</li>
</ul>
<p>We also define the function <code>find_in_file</code> and the buffer size.</p>
<p>The buffer size will be how many bytes we will read from the file at a time. More on this later.</p>
<p>The <code>open</code> function takes a path, and some flags, and returns a file descriptor. This file descriptor is how we will refer to the file from here on out. On most Unix systems, this will be the value 3, as it is the smallest available integer.</p>
<p>Different flags can be Or&rsquo;d together to create a mode that will determine access permissions.</p>
<ul>
<li><code>O_RDONLY</code> opens the file for only reading</li>
<li><code>O_WRONLY</code> opens the file for only writing</li>
<li><code>O_RDWR</code> opens the file for both</li>
</ul>
<p>Optional:</p>
<ul>
<li><code>O_APPEND</code> appends to the file after every write</li>
<li><code>O_CREAT</code> creates the file if it doesn&rsquo;t exist</li>
</ul>
<p>A complete list can be found <a href="https://www.gnu.org/software/libc/manual/html_node/Access-Modes.html">here</a>.</p>
<p>In this case, we <code>Or</code> the <code>RDONLY</code> flag, and the <code>CREAT</code> flag. This means, that we can only read the file, and if it doesn&rsquo;t exist, it will be created. If we Or&rsquo;d with a write flag, we would also be able to write to the file.</p>
<p>Next, we call our function, giving it the name &ldquo;file&rdquo;.</p>
<p>Finally, we close the file. When the process exits, the open files automatically close.</p>
<p>Next, the find_in_file function:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUFFSIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">find_in_file</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">phrase</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">current_line</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">is_eof</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">match_length</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">phrase</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">buf_len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">is_eof</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">((</span><span class="n">buf_len</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">BUFFSIZE</span><span class="p">))</span> <span class="o">!=</span> <span class="n">BUFFSIZE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">is_eof</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">buf_len</span> <span class="o">-</span> <span class="n">strlen</span><span class="p">(</span><span class="n">phrase</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">cur_cmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">while</span><span class="p">(</span><span class="n">cur_cmp</span> <span class="o">&lt;</span> <span class="n">match_length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">cur_cmp</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">current_line</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="k">goto</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span><span class="p">(</span><span class="n">tolower</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">cur_cmp</span><span class="p">])</span> <span class="o">!=</span> <span class="n">tolower</span><span class="p">(</span><span class="n">phrase</span><span class="p">[</span><span class="n">cur_cmp</span><span class="p">]))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">goto</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">cur_cmp</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Line: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">current_line</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nl">result</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>
<p>First, we create a buffer of size BUFFSIZE.</p>
</li>
<li>
<p>Then, we set some preliminary flags. The initial line is 1, and the offset has not reached the end of file. Finally, we set the length of the phrase to how many characters we have to match.</p>
</li>
<li>
<p>Now, we read BUFFSIZE bytes into the buffer. <code>read</code> returns the number of bytes it read, so if that number is less than the size of the buffer, we know that we have reached the end of the file. In that case, the while loop won&rsquo;t loop again.</p>
</li>
<li>
<p>Now that the bytes are in the buffer, we iterate through the current buffer with an algorithm to check if the characters match.</p>
</li>
<li>
<p>We check how many characters have been matched, and if the number of characters matched is equal to the length of the phrase, that is a match. If so, we print the line number. We increment the line number if we encounter a newline character.</p>
</li>
</ul>
<h3 id="other-functions">Other Functions<a hidden class="anchor" aria-hidden="true" href="#other-functions">#</a></h3>
<p>There are some other functions that may be useful to know.</p>
<h4 id="creat"><code>creat</code><a hidden class="anchor" aria-hidden="true" href="#creat">#</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">creat</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">,</span> <span class="n">mode_t</span> <span class="n">mode</span><span class="p">);</span>
</span></span></code></pre></div><p>This function is equal to <code>open(path, O_WRONLY | O_CREAT | O_TRUNC, mode)</code>;</p>
<p>Notice how it is opened for writing only.</p>
<h4 id="lseek"><code>lseek</code><a hidden class="anchor" aria-hidden="true" href="#lseek">#</a></h4>
<p>The <code>lseek</code> function is another useful function that is used to manipulate the offset (aka current position in a file).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">off_t</span> <span class="nf">lseek</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">whence</span><span class="p">);</span>
</span></span></code></pre></div><p>offset could mean different things depending on <code>whence</code>.</p>
<ul>
<li>If whence is SEEK_SET, the files current position if offset from the beginning.</li>
<li>If whence is SEEK_CUR, the files current position if offset from the current position.</li>
<li>If whence is SEEK_END, the files current position if offset from the size of the file.</li>
</ul>
<p>If you seek past the end of the file, that creates a hole in the file. The hole is not backed by a storage medium.</p>
<p>Reading and writing operations also manage the offset of the file.</p>
<h4 id="dup-and-dup2"><code>dup</code> and <code>dup2</code><a hidden class="anchor" aria-hidden="true" href="#dup-and-dup2">#</a></h4>
<p>The <code>dup</code> functions just clone the file descriptor in the file descriptor table of that process. One special thing about the <code>dup</code> function is that it chooses the lowest available file descriptor, allowing us to do some special things that we will see later.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">dup</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">dup2</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd2</span><span class="p">);</span>
</span></span></code></pre></div><p><code>dup</code> duplicates <em>fd</em> and gives the result descriptor the lowest available identifier.
<code>dup2</code> duplicates <em>fd</em>, giving the new one <em>fd2</em>. If <em>fd2</em> is open, it closes it.</p>
<p><code>dup</code> can be used to, for example, redirect stdout to a file like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="n">close</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">dup</span><span class="p">(</span><span class="mi">34</span><span class="p">);</span>
</span></span></code></pre></div><p>We clone the file descriptor of some file, duplicating it on standard output.</p>
<h4 id="sync-functions"><code>sync</code> functions<a hidden class="anchor" aria-hidden="true" href="#sync-functions">#</a></h4>
<p>Unix systems have a buffer cache that IO runs through. When we <code>write</code> to a file, it usually passes through the kernel&rsquo;s buffer cache, and is written at some later time.</p>
<p>The buffer is written eventually, especially when the buffer needs to be reused. The <code>sync</code> functions just flush the buffer cache.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">fsync</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">sync</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span></span></code></pre></div><p><code>sync</code> queues block buffers for writing. It doesn&rsquo;t wait for the writing to take place
<code>fsync</code> queues only one file descriptor for writing. It does wait for the writing to take place.</p>
<h2 id="c-standard-i-o">C Standard I/O<a hidden class="anchor" aria-hidden="true" href="#c-standard-i-o">#</a></h2>
<p>The C Standard I/O works a little bit differently. We still read and write and interact with files, but this I/O is a little bit more featureful because it comes with internal buffering. The FILE object maintains its own buffer so it doesn&rsquo;t have to make a system call to read or write every single time.</p>
<p>It may read a little more the first time, so it would just be getting data from its own buffer.</p>
<p>The 3 kinds of I/O are:</p>
<ul>
<li>Character I/O, where one character is read or written</li>
<li>Line I/O, where one line is read or written</li>
<li>Direct I/O, where the exact number of objects and size of each object is specified.</li>
</ul>
<h3 id="buffering">Buffering<a hidden class="anchor" aria-hidden="true" href="#buffering">#</a></h3>
<p>The main benefit of standard IO is the default buffering functionalities, which aims to reduce the number of <code>read</code> and <code>write</code> calls a process makes.</p>
<p>There are 3 kinds of buffering:</p>
<ul>
<li>
<p>Fully buffered streams maintain a dynamically allocated buffer. The IO is only performed once the buffer is filled up, or the process flushes the buffers.</p>
<p>A process can <em>flush</em> a buffer by calling <code>fflush(3)</code> or <code>exit(3)</code></p>
<p>Most file streams are fully buffered</p>
</li>
<li>
<p>Line buffered streams only perform input or output when they encounter a new line (&rsquo;\n&rsquo;) character. You can write characters to a buffer, and know that they aren&rsquo;t being flushed unless the newline character is written.</p>
<p>Terminal streams like stdout are line buffered</p>
</li>
<li>
<p>Unbuffered streams just <code>read</code> and <code>write</code> directly.</p>
<p>stderr is unbuffered because the result should appear whether or not a newline is encountered.</p>
</li>
</ul>
<h4 id="set-buffering">Set buffering<a hidden class="anchor" aria-hidden="true" href="#set-buffering">#</a></h4>
<p>Buffering can be set using <code>setbuf(3)</code> and <code>setvbuf(3)</code>. View the man pages for a more detailed look at the functions.</p>
<h3 id="basic-implementation">Basic implementation<a hidden class="anchor" aria-hidden="true" href="#basic-implementation">#</a></h3>
<p>This is a basic implementation with buffering. This time when we use fopen, we are returned a <code>FILE*</code>. Instead of Or-ing options, we can just add a string of permissions. In this case, we only need &ldquo;r&rdquo; (read) permissions.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#define BUFFSIZE 4096
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">find_in_file</span><span class="p">(</span><span class="n">FILE</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Open File with flags */</span>
</span></span><span class="line"><span class="cl">    <span class="n">FILE</span><span class="o">*</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">&#34;search.c&#34;</span><span class="p">,</span> <span class="s">&#34;r&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">find_in_file</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="s">&#34;file&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">fclose</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Now, we implement the same basic algorithm as before:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUFFSIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">find_in_file</span><span class="p">(</span><span class="n">FILE</span><span class="o">*</span> <span class="n">fp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">phrase</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">current_line</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">int</span> <span class="n">match_length</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">phrase</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">BUFFSIZE</span><span class="p">,</span> <span class="n">fp</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">buf_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">buf_len</span> <span class="o">&lt;</span> <span class="n">match_length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">buf_len</span> <span class="o">-</span> <span class="n">match_length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">cur_cmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">while</span><span class="p">(</span><span class="n">cur_cmp</span> <span class="o">&lt;</span> <span class="n">match_length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span><span class="p">(</span><span class="n">tolower</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">cur_cmp</span><span class="p">])</span> <span class="o">!=</span> <span class="n">tolower</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">phrase</span><span class="p">[</span><span class="n">cur_cmp</span><span class="p">]))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">goto</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">cur_cmp</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Line: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">current_line</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nl">result</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">current_line</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This time fgets reads only one line at a time into the buffer. We implement the same algorithm, though this one works a little bit better.</p>
<h3 id="other-functions">Other Functions<a hidden class="anchor" aria-hidden="true" href="#other-functions">#</a></h3>
<p>Some functions commonly used for Binary I/O are the fread and write functions.</p>
<p>For example, a binary array can be written to a file as such:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">float</span> <span class="n">buf</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">fwrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Also, an equivalent to the lseek function above is <code>fseek</code> and <code>ftell</code>.</p>
<p><code>ftell</code> simply returns the current offset.</p>
<p><code>fseek</code> can be used to set the offset, with the same file modes.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">long</span> <span class="nf">ftell</span><span class="p">(</span><span class="n">FILE</span><span class="o">*</span> <span class="n">fp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">fseek</span><span class="p">(</span><span class="n">FILE</span><span class="o">*</span> <span class="n">fp</span><span class="p">,</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">whence</span><span class="p">);</span>
</span></span></code></pre></div><h4 id="temp-files">Temp files<a hidden class="anchor" aria-hidden="true" href="#temp-files">#</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">char</span><span class="o">*</span> <span class="nf">tmpname</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">FILE</span><span class="o">*</span> <span class="nf">tmpfile</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span></span></code></pre></div><p>These functions can be used to generate a temporary file. <code>tmpname</code> just returns the pathname, whereas <code>tmpfile</code> returns the stream.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://www.dumrich.com/tags/unix/">Unix</a></li>
      <li><a href="https://www.dumrich.com/tags/c/">C</a></li>
      <li><a href="https://www.dumrich.com/tags/files/">Files</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://www.dumrich.com/posts/rocky-iii/">
    <span class="title">« Prev</span>
    <br>
    <span>Rocky III (1982) Movie Review</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share File I/O on Unix systems on twitter"
        href="https://twitter.com/intent/tweet/?text=File%20I%2fO%20on%20Unix%20systems&amp;url=https%3a%2f%2fwww.dumrich.com%2fposts%2funix-file-io%2f&amp;hashtags=Unix%2cC%2cFiles">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share File I/O on Unix systems on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwww.dumrich.com%2fposts%2funix-file-io%2f&amp;title=File%20I%2fO%20on%20Unix%20systems&amp;summary=File%20I%2fO%20on%20Unix%20systems&amp;source=https%3a%2f%2fwww.dumrich.com%2fposts%2funix-file-io%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share File I/O on Unix systems on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fwww.dumrich.com%2fposts%2funix-file-io%2f&title=File%20I%2fO%20on%20Unix%20systems">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share File I/O on Unix systems on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.dumrich.com%2fposts%2funix-file-io%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
</div>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://www.dumrich.com/">dumrich.com</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
